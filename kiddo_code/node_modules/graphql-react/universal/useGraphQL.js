'use strict';

var React = require('react');

var ReactDOM = require('react-dom');

var GraphQL = require('./GraphQL');

var GraphQLContext = require('./GraphQLContext');

var FirstRenderDateContext = require('./private/FirstRenderDateContext');

var graphqlFetchOptions = require('./private/graphqlFetchOptions');

var hashObject = require('./private/hashObject');

module.exports = function useGraphQL(_ref) {
  var fetchOptionsOverride = _ref.fetchOptionsOverride,
    loadOnMount = _ref.loadOnMount,
    loadOnReload = _ref.loadOnReload,
    loadOnReset = _ref.loadOnReset,
    reloadOnLoad = _ref.reloadOnLoad,
    resetOnLoad = _ref.resetOnLoad,
    operation = _ref.operation;
  if (reloadOnLoad && resetOnLoad)
    throw new Error(
      'useGraphQL() options “reloadOnLoad” and “resetOnLoad” can’t both be true.'
    );
  var graphql = React.useContext(GraphQLContext);
  if (typeof graphql === 'undefined')
    throw new Error('GraphQL context missing.');
  if (!(graphql instanceof GraphQL))
    throw new Error('GraphQL context must be a GraphQL instance.');
  var fetchOptions = graphqlFetchOptions(operation);
  if (fetchOptionsOverride) fetchOptionsOverride(fetchOptions);
  var fetchOptionsHash = hashObject(fetchOptions);

  var _React$useState = React.useState(fetchOptionsHash),
    cacheKey = _React$useState[0],
    setCacheKey = _React$useState[1];

  var _React$useState2 = React.useState(graphql.cache[cacheKey]),
    cacheValue = _React$useState2[0],
    setCacheValue = _React$useState2[1];

  var _React$useState3 = React.useState(cacheKey in graphql.operations),
    loading = _React$useState3[0],
    setLoading = _React$useState3[1];

  if (cacheKey !== fetchOptionsHash) {
    setCacheKey((cacheKey = fetchOptionsHash));
    setCacheValue((cacheValue = graphql.cache[cacheKey]));
    setLoading((loading = cacheKey in graphql.operations));
  }

  var load = React.useCallback(
    function () {
      var _graphql$operate = graphql.operate({
          operation: operation,
          fetchOptionsOverride: fetchOptionsOverride,
          reloadOnLoad: reloadOnLoad,
          resetOnLoad: resetOnLoad,
        }),
        cacheKey = _graphql$operate.cacheKey,
        cacheValue = _graphql$operate.cacheValue,
        cacheValuePromise = _graphql$operate.cacheValuePromise;

      setLoading(true);
      setCacheKey(cacheKey);
      setCacheValue(cacheValue);
      return cacheValuePromise;
    },
    [fetchOptionsOverride, graphql, operation, reloadOnLoad, resetOnLoad]
  );
  var isMountedRef = React.useRef(false);
  React.useEffect(
    function () {
      isMountedRef.current = true;

      function onFetch(_ref2) {
        var fetchingCacheKey = _ref2.cacheKey;
        if (cacheKey === fetchingCacheKey && isMountedRef.current)
          setLoading(true);
      }

      function onCache(_ref3) {
        var cachedCacheKey = _ref3.cacheKey,
          cacheValue = _ref3.cacheValue;
        if (cacheKey === cachedCacheKey && isMountedRef.current)
          ReactDOM.unstable_batchedUpdates(function () {
            setLoading(false);
            setCacheValue(cacheValue);
          });
      }

      function onReload(_ref4) {
        var exceptCacheKey = _ref4.exceptCacheKey;
        if (
          cacheKey !== exceptCacheKey &&
          loadOnReload &&
          cacheValue &&
          isMountedRef.current
        )
          load();
      }

      function onReset(_ref5) {
        var exceptCacheKey = _ref5.exceptCacheKey;
        if (cacheKey !== exceptCacheKey && isMountedRef.current)
          if (loadOnReset) load();
          else setCacheValue(graphql.cache[cacheKey]);
      }

      graphql.on('fetch', onFetch);
      graphql.on('cache', onCache);
      graphql.on('reload', onReload);
      graphql.on('reset', onReset);
      return function () {
        isMountedRef.current = false;
        graphql.off('fetch', onFetch);
        graphql.off('cache', onCache);
        graphql.off('reload', onReload);
        graphql.off('reset', onReset);
      };
    },
    [cacheKey, cacheValue, graphql, load, loadOnReload, loadOnReset]
  );

  var _React$useState4 = React.useState(),
    loadedOnMountCacheKey = _React$useState4[0],
    setLoadedOnMountCacheKey = _React$useState4[1];

  var firstRenderDate = React.useContext(FirstRenderDateContext);
  React.useEffect(
    function () {
      if (
        loadOnMount &&
        cacheKey !== loadedOnMountCacheKey &&
        !(cacheValue && new Date() - firstRenderDate < 1000)
      ) {
        setLoadedOnMountCacheKey(cacheKey);
        load();
      }
    },
    [
      cacheKey,
      cacheValue,
      firstRenderDate,
      load,
      loadOnMount,
      loadedOnMountCacheKey,
    ]
  );
  if (graphql.ssr && loadOnMount && !cacheValue)
    graphql.operate({
      operation: operation,
      fetchOptionsOverride: fetchOptionsOverride,
      reloadOnLoad: reloadOnLoad,
      resetOnLoad: resetOnLoad,
    });
  return {
    load: load,
    loading: loading,
    cacheKey: cacheKey,
    cacheValue: cacheValue,
  };
};
